// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as EnrichApi from "../../../index.js";

export declare namespace PeopleSearchClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class PeopleSearchClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<PeopleSearchClient.Options>;

    constructor(options: PeopleSearchClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Search for people at a specific company using cascading ICP (Ideal Customer Profile) filter levels.
     *
     * **How it works:**
     * 1. Provide a company LinkedIn URL to target
     * 2. Optionally define 1-10 cascade levels, each with independent ICP criteria. If omitted, a default 4-level cascade is used: CEO/Founder → C-Suite → VP → Director.
     * 3. Levels are processed in order — results from earlier levels are excluded from later ones
     * 4. Each candidate is scored against the ICP criteria of their matching cascade level
     * 5. Results are returned sorted by score descending
     *
     * **Scoring:** Each candidate gets a normalized 0-100 score based on title match (30pts), job level (20pts), skills overlap (15pts), location match (15pts), current job status (10pts), profile completeness (5pts), tenure (5pts), and optional seniority priority bonus (0-30pts). The score is normalized against only the dimensions specified in the cascade level.
     *
     * **Credits:** 1 credit per profile returned. No charge if 0 results.
     *
     * @param {EnrichApi.WaterfallIcpSearchRequest} request
     * @param {PeopleSearchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link EnrichApi.BadRequestError}
     * @throws {@link EnrichApi.UnauthorizedError}
     * @throws {@link EnrichApi.PaymentRequiredError}
     * @throws {@link EnrichApi.TooManyRequestsError}
     * @throws {@link EnrichApi.InternalServerError}
     *
     * @example
     *     await client.peopleSearch.waterfallIcpSearch({
     *         company_linkedin_url: "https://www.linkedin.com/company/google/"
     *     })
     */
    public waterfallIcpSearch(
        request: EnrichApi.WaterfallIcpSearchRequest,
        requestOptions?: PeopleSearchClient.RequestOptions,
    ): core.HttpResponsePromise<EnrichApi.WaterfallIcpSearchResponse> {
        return core.HttpResponsePromise.fromPromise(this.__waterfallIcpSearch(request, requestOptions));
    }

    private async __waterfallIcpSearch(
        request: EnrichApi.WaterfallIcpSearchRequest,
        requestOptions?: PeopleSearchClient.RequestOptions,
    ): Promise<core.WithRawResponse<EnrichApi.WaterfallIcpSearchResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "people-search/waterfall-icp-search",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as EnrichApi.WaterfallIcpSearchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new EnrichApi.BadRequestError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 401:
                    throw new EnrichApi.UnauthorizedError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 402:
                    throw new EnrichApi.PaymentRequiredError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 429:
                    throw new EnrichApi.TooManyRequestsError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 500:
                    throw new EnrichApi.InternalServerError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.EnrichApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/people-search/waterfall-icp-search",
        );
    }

    /**
     * Find employees at a specific company by LinkedIn URL. Optionally filter by job level, job function, country, continent, or sales region.
     *
     * **Credits:** 1 credit per result returned. No charge if 0 results.
     *
     * **Pagination:** Use `page` and `max_results` to paginate through results.
     *
     * @param {EnrichApi.EmployeeFinderRequest} request
     * @param {PeopleSearchClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link EnrichApi.BadRequestError}
     * @throws {@link EnrichApi.UnauthorizedError}
     * @throws {@link EnrichApi.PaymentRequiredError}
     * @throws {@link EnrichApi.TooManyRequestsError}
     * @throws {@link EnrichApi.InternalServerError}
     *
     * @example
     *     await client.peopleSearch.employeeFinder({
     *         company_linkedin_url: "https://www.linkedin.com/company/google/"
     *     })
     */
    public employeeFinder(
        request: EnrichApi.EmployeeFinderRequest,
        requestOptions?: PeopleSearchClient.RequestOptions,
    ): core.HttpResponsePromise<EnrichApi.EmployeeFinderResponse> {
        return core.HttpResponsePromise.fromPromise(this.__employeeFinder(request, requestOptions));
    }

    private async __employeeFinder(
        request: EnrichApi.EmployeeFinderRequest,
        requestOptions?: PeopleSearchClient.RequestOptions,
    ): Promise<core.WithRawResponse<EnrichApi.EmployeeFinderResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "people-search/employee-finder",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as EnrichApi.EmployeeFinderResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new EnrichApi.BadRequestError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 401:
                    throw new EnrichApi.UnauthorizedError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 402:
                    throw new EnrichApi.PaymentRequiredError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 429:
                    throw new EnrichApi.TooManyRequestsError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                case 500:
                    throw new EnrichApi.InternalServerError(
                        _response.error.body as EnrichApi.ErrorEnvelope,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.EnrichApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/people-search/employee-finder",
        );
    }
}
